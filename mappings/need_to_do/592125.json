[{"code":"class K{static loadAllMissingChannels(){let e=O.Z.getGuildIds().filter(e=>!Z.has(e));return this.loadGuildIds(e)}static loadGuildFromChannelId(e){var t;return null==e?null:K.loadGuildIds([null==(t=X(e))?void 0:t.guild_id])}static loadGuildIds(e){let t=e.filter(E.lm);if(0===t.length)return null;let n=c.Z.database();if(null==n||!t.some(e=>!Z.has(e)))return null;let r=B;return(0,u.gs)(\"loadChannels\",async()=>{let e=t.map(e=>{if(Z.has(e))return null;if(null!=F[e])return N.fileOnly(\"Skipping loading \".concat(e,\" because a load is pending\")),null;let t=d.Z.getAsync(n,e).then(t=>(N.fileOnly(\"Lazy loaded channels for \".concat(e,\" #:\").concat(t.length)),{guildId:e,channels:t}));return F[e]=t,{guildId:e,promise:t}}).filter(E.lm),i=e.map(e=>e.promise);try{let t=await Promise.all(i);if(B!==r)return N.fileOnly(\"lastResetTime has changed, skipping loads for \"+e.map(e=>e.guildId)),null;let n=t.filter(e=>!Z.has(e.guildId));await l.Z.dispatch({type:\"LOAD_CHANNELS\",channels:n})}catch(t){for(let n of(N.error(\"Failed to load channels from disk for \"+e.map(e=>e.guildId),t),e))delete F[n.guildId];throw t}return null})}}"}]